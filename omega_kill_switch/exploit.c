#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/ethernet.h>
#include <net/if.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#include <linux/if_ether.h>
#include <linux/if_packet.h>
#include <arpa/inet.h>

#include <errno.h>

#define DEVICE_NAME "enx00e04c0c0029"
#define SENDER_IP_ADR "1.2.3.4"


void random_ip_addr(unsigned char *adr1){
	for(int i = 0; i<4; i++){
		*(adr1+i) = rand()%256;
	}
}

void random_mac_addr(unsigned char *adr1, unsigned char *adr2){
	for(int i = 0; i<ETHER_ADDR_LEN; i++){
		unsigned char tmp = rand()%256;
		*(adr1+i) = tmp;
		*(adr2+i) = tmp;
	}
}

void get_index_mac(struct sockaddr_ll *send, struct ether_arp *req){
	int tmp_socket_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);
	if(tmp_socket_fd == -1){
		printf("Error creating socket\n");
		return;
	}

	struct ifreq ifr;

	memset(&ifr, 0, sizeof(struct ifreq));

	strcpy(ifr.ifr_name, DEVICE_NAME);

	if(ioctl(tmp_socket_fd, SIOCGIFINDEX, &ifr) < 0){
		printf("Error retrieving index of %s\n", DEVICE_NAME);
		return;
	}

	send->sll_ifindex = ifr.ifr_ifindex;

	if(ioctl(tmp_socket_fd, SIOCGIFHWADDR, &ifr) < 0){
		printf("Error retrieving MAC address of %s\n", DEVICE_NAME);
		return;
	}

	memcpy(req->arp_sha, ifr.ifr_hwaddr.sa_data, ETHER_ADDR_LEN);
	close(tmp_socket_fd);
}

void send_rd_msg(int socket_fd, struct sockaddr_ll * send_adress, struct ether_arp * req){
	random_mac_addr(send_adress->sll_addr, req->arp_tha);
	random_ip_addr(req->arp_tpa);

	if(sendto(socket_fd, req, sizeof(struct ether_arp), 0, (struct sockaddr *) send_adress, sizeof(struct sockaddr_ll))  < 0) {
		printf("Error sending : %s\n",strerror(errno));
		return;
	}
}

int main(){
	srand(time(NULL));

	int socket_fd = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));
	if(socket_fd == -1){
		printf("Error creating socket : %s\n", strerror(errno));
		return 1;
	}

	unsigned char mac_adr[ETHER_ADDR_LEN];
	struct sockaddr_ll send_address;
	struct ether_arp req;


	//fill both structs with zeros
	memset(&send_address, 0, sizeof(struct sockaddr_ll));
	memset(&req, 0, sizeof(struct ether_arp));

	//complete first struct
	send_address.sll_family = AF_PACKET;
	send_address.sll_halen = ETHER_ADDR_LEN;
	send_address.sll_protocol = htons(ETH_P_ARP);
	get_index_mac(&send_address, &req);
	

	/*
	 * To broadcast : 
	 * 
	 * memcpy(send_address.sll_addr, "\xff\xff\xff\xff\xff\xff", 6);
	 *
	 */
	
	

	//turn sender_ip into right format
	int tmp_sender_ip[4];
	unsigned char sender_ip[4];
	
	sscanf(SENDER_IP_ADR, "%d.%d.%d.%d", tmp_sender_ip, tmp_sender_ip+1, tmp_sender_ip+2, tmp_sender_ip+3);

	for(int i = 0; i<4; i++)
		sender_ip[i] = (unsigned char) tmp_sender_ip[i];

	//complete second struct
	//inspired from http://www.microhowto.info/howto/send_an_arbitrary_ethernet_frame_using_an_af_packet_socket_in_c.html
	req.arp_hrd = htons(ARPHRD_ETHER);
	req.arp_pro = htons(ETH_P_IP);
	req.arp_hln = ETHER_ADDR_LEN;
	req.arp_pln = sizeof(in_addr_t);
	req.arp_op = htons(ARPOP_REQUEST);
	memcpy(req.arp_spa, sender_ip, 4);
	memset(req.arp_tha, 0, sizeof(req.arp_tha));

	//send infinite number of packets
	while(1){
		send_rd_msg(socket_fd, &send_address, &req);
	}

	printf("Exit normally\n");
	return 0;
}
